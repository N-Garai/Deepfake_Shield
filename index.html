<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepfake Spy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script> <!-- EXIF Library -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .drop-zone {
            border: 2px dashed #4a5568;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .drop-zone--over {
            border-color: #4c51bf;
            background-color: #2c314d;
        }
        .loader {
            border-top-color: #4c51bf;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        .progress-circle {
            transition: stroke-dashoffset 0.5s ease-out;
        }
        .modal {
            transition: opacity 0.25s ease;
        }
        #fetchUrlBtn:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Deepfake Spy</h1>
            <p class="text-gray-400">Upload an image to analyze it for signs of AI manipulation.</p>
        </header>

        <main class="bg-gray-800 shadow-2xl rounded-lg p-6 md:p-8">
            <div id="inputMethodContainer">
                <!-- Upload Area -->
                <div id="uploadContainer">
                    <div id="dropZone" class="drop-zone p-10 text-center cursor-pointer hover:bg-gray-700/50">
                        <input type="file" id="fileInput" class="hidden" accept="image/png, image/jpeg, image/webp">
                        <div class="flex flex-col items-center">
                            <svg class="w-16 h-16 text-gray-500 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-4-4V7a4 4 0 014-4h10a4 4 0 014 4v5a4 4 0 01-4 4H7z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            <p class="text-gray-400">
                                <span class="font-semibold text-indigo-400">Click to upload</span> or drag and drop
                            </p>
                            <p class="text-xs text-gray-500 mt-1">PNG, JPG, or WEBP</p>
                        </div>
                    </div>
                </div>

                <!-- Divider -->
                <div class="relative flex py-5 items-center">
                    <div class="flex-grow border-t border-gray-600"></div>
                    <span class="flex-shrink mx-4 text-gray-500">OR</span>
                    <div class="flex-grow border-t border-gray-600"></div>
                </div>

                <!-- URL Input Area -->
                <div id="urlContainer" class="flex flex-col sm:flex-row gap-3">
                    <input type="url" id="imageUrlInput" placeholder="Paste image URL here..." class="flex-1 bg-gray-900 border border-gray-600 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-gray-500">
                    <button id="fetchUrlBtn" class="bg-gray-600 text-white font-semibold py-3 px-5 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition duration-300">
                        Fetch Image
                    </button>
                </div>
            </div>

            <!-- Image Preview -->
            <div id="previewContainer" class="hidden text-center mt-6">
                <div class="relative inline-block mx-auto">
                    <img id="imagePreview" src="#" alt="Image Preview" class="max-w-full max-h-72 mx-auto rounded-lg shadow-md">
                    <canvas id="heatmapCanvas" class="absolute top-0 left-0 w-full h-full rounded-lg pointer-events-none" style="display: none;"></canvas>
                </div>
                <div class="flex justify-center items-center gap-4 mt-4">
                    <button id="showExifBtn" class="text-sm text-blue-400 hover:text-blue-300 hidden">Show EXIF Data</button>
                    <button id="removeImageBtn" class="text-sm text-red-400 hover:text-red-300">Remove Image</button>
                </div>
            </div>

            <!-- Analyze Button -->
            <div class="mt-8 text-center">
                <button id="analyzeBtn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-300 disabled:bg-gray-600 disabled:cursor-not-allowed disabled:shadow-none" disabled>
                    Analyze Image
                </button>
            </div>

             <!-- Results / Loading Area -->
            <div id="resultsContainer" class="mt-8 pt-6 border-t border-gray-700 hidden">
                <!-- Loading State -->
                <div id="loadingState" class="text-center hidden">
                    <div class="flex items-center justify-center">
                         <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mb-4"></div>
                    </div>
                    <p class="text-gray-400 animate-pulse">Analyzing image... this may take a moment.</p>
                </div>

                <!-- Results Display -->
                <div id="resultsContent" class="hidden">
                    <h2 class="text-2xl font-bold text-center text-white mb-6">Analysis Result</h2>
                    <div class="bg-gray-900/50 rounded-lg p-6 flex flex-col md:flex-row items-center gap-6">
                        <div class="relative w-36 h-36 flex items-center justify-center">
                            <svg class="transform -rotate-90 w-full h-full">
                                <circle class="text-gray-700" stroke-width="10" stroke="currentColor" fill="transparent" r="58" cx="72" cy="72" />
                                <circle id="progressCircle" class="text-indigo-500" stroke-width="10" stroke-linecap="round" stroke="currentColor" fill="transparent" r="58" cx="72" cy="72" style="stroke-dasharray: 364; stroke-dashoffset: 364;" />
                            </svg>
                            <span id="probabilityText" class="absolute text-3xl font-bold">0%</span>
                        </div>
                        <div class="flex-1 text-center md:text-left">
                            <p class="text-lg font-medium text-gray-400">Deepfake Probability</p>
                            <p id="verdictText" class="text-2xl font-semibold mt-1">Calculating...</p>
                            <div id="analysisBox" class="mt-4 text-sm text-gray-400 bg-gray-800 p-3 rounded-md max-h-40 overflow-y-auto">
                                <p id="analysisText">Waiting for analysis...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Forensic Breakdown -->
                    <div id="forensicsReport" class="mt-6 hidden">
                        <h3 class="text-xl font-bold text-center text-white mb-4">Forensic Breakdown</h3>
                        <div id="forensicsList" class="space-y-3">
                            <!-- This will be populated by JavaScript -->
                        </div>
                    </div>

                </div>
                 <!-- Error Message -->
                <div id="errorState" class="hidden text-center text-red-400 bg-red-900/50 p-4 rounded-lg">
                    <p><strong>Analysis Failed</strong></p>
                    <p id="errorMessage">An unexpected error occurred. Please try again.</p>
                </div>
            </div>
            
            <footer class="text-center mt-8 text-xs text-gray-500">
                <p>Disclaimer: This tool uses AI to estimate the likelihood of an image being a deepfake. It is not 100% accurate and should be used for informational purposes only.</p>
            </footer>
        </main>
    </div>

    <!-- EXIF Modal -->
    <div id="exifModal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 invisible opacity-0">
        <div class="bg-gray-800 text-gray-200 rounded-lg shadow-2xl w-full max-w-lg max-h-[80vh] overflow-y-auto p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Image Metadata (EXIF)</h2>
                <button id="closeExifBtn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="exifDataContainer" class="text-sm space-y-2">
                <!-- EXIF data will be populated here -->
            </div>
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const imagePreview = document.getElementById('imagePreview');
        const previewContainer = document.getElementById('previewContainer');
        const removeImageBtn = document.getElementById('removeImageBtn');
        const resultsContainer = document.getElementById('resultsContainer');
        const loadingState = document.getElementById('loadingState');
        const resultsContent = document.getElementById('resultsContent');
        const errorState = document.getElementById('errorState');
        const errorMessage = document.getElementById('errorMessage');

        // New URL elements
        const inputMethodContainer = document.getElementById('inputMethodContainer');
        const imageUrlInput = document.getElementById('imageUrlInput');
        const fetchUrlBtn = document.getElementById('fetchUrlBtn');

        const probabilityText = document.getElementById('probabilityText');
        const verdictText = document.getElementById('verdictText');
        const analysisText = document.getElementById('analysisText');
        const progressCircle = document.getElementById('progressCircle');

        // Heatmap element
        const heatmapCanvas = document.getElementById('heatmapCanvas');

        // Forensics elements
        const forensicsReport = document.getElementById('forensicsReport');
        const forensicsList = document.getElementById('forensicsList');

        // EXIF elements
        const exifModal = document.getElementById('exifModal');
        const showExifBtn = document.getElementById('showExifBtn');
        const closeExifBtn = document.getElementById('closeExifBtn');
        const exifDataContainer = document.getElementById('exifDataContainer');

        let fileObject = null;
        let base64ImageData = null;
        let lastApiCallTimestamp = 0; // Tracks the time of the last API call

        // --- Input Listeners ---
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drop-zone--over');
        });
        ['dragleave', 'dragend'].forEach(type => {
            dropZone.addEventListener(type, () => {
                dropZone.classList.remove('drop-zone--over');
            });
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drop-zone--over');
            if (e.dataTransfer.files.length) {
                const droppedFile = e.dataTransfer.files[0];
                if (droppedFile.type.startsWith('image/')) {
                    handleFile(droppedFile);
                } else {
                    showError('Please drop an image file (PNG, JPG, WEBP).');
                }
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        });

        removeImageBtn.addEventListener('click', resetState);
        fetchUrlBtn.addEventListener('click', handleUrlFetch);
        imageUrlInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleUrlFetch();
            }
        });


        // --- URL Fetching Logic ---
        async function handleUrlFetch() {
            const url = imageUrlInput.value.trim();
            if (!url) {
                showError('Please enter a valid image URL.');
                return;
            }

            fetchUrlBtn.disabled = true;
            fetchUrlBtn.textContent = 'Fetching...';
            errorState.classList.add('hidden'); // Hide previous errors

            // Use a CORS proxy to bypass browser security restrictions.
            // This service fetches the image on its server and sends it back to us.
            const proxyUrl = 'https://api.allorigins.win/raw?url=';
            const fetchUrl = proxyUrl + encodeURIComponent(url);

            try {
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch image. Server responded with status: ${response.status}`);
                }
                const blob = await response.blob();
                if (!blob.type.startsWith('image/')) {
                    throw new Error('The provided URL does not point to a valid image file.');
                }
                const fileName = url.substring(url.lastIndexOf('/') + 1) || 'image_from_url.jpg';
                const file = new File([blob], fileName, { type: blob.type });
                handleFile(file);
            } catch (error) {
                console.error('Error fetching image from URL:', error);
                showError(`Could not fetch image. The URL might be invalid, private, or the server might be blocking requests. Details: ${error.message}`);
            } finally {
                fetchUrlBtn.disabled = false;
                fetchUrlBtn.textContent = 'Fetch Image';
            }
        }

        // --- File Handling ---
        function handleFile(file) {
            fileObject = file;
            readExifData(file); // Attempt to read EXIF data
            
            const ctx = heatmapCanvas.getContext('2d');
            ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
            heatmapCanvas.style.display = 'none';

            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                base64ImageData = e.target.result.split(',')[1];
                inputMethodContainer.classList.add('hidden');
                previewContainer.classList.remove('hidden');
                analyzeBtn.disabled = false;
                resultsContainer.classList.add('hidden');
                resultsContent.classList.add('hidden');
                errorState.classList.add('hidden');
            };
            reader.readAsDataURL(fileObject);
        }

        function resetState() {
            fileObject = null;
            base64ImageData = null;
            fileInput.value = ''; 
            imageUrlInput.value = '';
            inputMethodContainer.classList.remove('hidden');
            previewContainer.classList.add('hidden');
            analyzeBtn.disabled = true;
            resultsContainer.classList.add('hidden');
            resultsContent.classList.add('hidden');
            errorState.classList.add('hidden');
            showExifBtn.classList.add('hidden');
            forensicsReport.classList.add('hidden');

            const ctx = heatmapCanvas.getContext('2d');
            ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
            heatmapCanvas.style.display = 'none';
        }

        // --- EXIF Data Logic ---
        function readExifData(file) {
            EXIF.getData(file, function() {
                const allTags = EXIF.getAllTags(this);
                if (Object.keys(allTags).length === 0) {
                    exifDataContainer.innerHTML = '<p class="text-gray-500">No EXIF metadata found in this image. It might have been stripped.</p>';
                    showExifBtn.classList.add('hidden');
                    return;
                }
                
                let html = '<dl class="grid grid-cols-3 gap-x-4 gap-y-2">';
                const tagsToShow = {
                    'Make': 'Camera Make', 'Model': 'Camera Model', 'DateTime': 'Date Taken',
                    'Software': 'Software', 'ExposureTime': 'Exposure Time', 'FNumber': 'F-Number',
                    'ISOSpeedRatings': 'ISO', 'GPSLatitude': 'Latitude', 'GPSLongitude': 'Longitude'
                };

                for (const tag in tagsToShow) {
                    if (allTags[tag]) {
                         html += `<dt class="font-semibold text-gray-400 col-span-1">${tagsToShow[tag]}</dt>`;
                         html += `<dd class="text-white col-span-2">${allTags[tag]}</dd>`;
                    }
                }
                html += '</dl>';

                exifDataContainer.innerHTML = html;
                showExifBtn.classList.remove('hidden');
            });
        }

        showExifBtn.addEventListener('click', () => exifModal.classList.remove('invisible', 'opacity-0'));
        closeExifBtn.addEventListener('click', () => exifModal.classList.add('invisible', 'opacity-0'));
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !exifModal.classList.contains('invisible')) {
                closeExifBtn.click();
            }
        });

        // --- API Call and Analysis ---
        analyzeBtn.addEventListener('click', () => {
            if (!base64ImageData) {
                showError('Please select an image first.');
                return;
            }
            performAnalysis();
        });

        async function performAnalysis() {
            // --- Rate Limiting Logic ---
            const now = Date.now();
            const COOLDOWN_PERIOD = 10000; // 10 seconds in milliseconds
            if (now - lastApiCallTimestamp < COOLDOWN_PERIOD) {
                const timeLeft = Math.ceil((COOLDOWN_PERIOD - (now - lastApiCallTimestamp)) / 1000);
                showError(`To stay within the free tier, please wait ${timeLeft} more seconds before the next analysis.`);
                return; // Stop the function here
            }
            // --- End Rate Limiting Logic ---

            resultsContainer.classList.remove('hidden');
            resultsContent.classList.add('hidden');
            loadingState.classList.remove('hidden');
            errorState.classList.add('hidden');
            analyzeBtn.disabled = true;
            
            lastApiCallTimestamp = Date.now(); // Update timestamp before the call

            const apiKey = "%VITE_GEMINI_API_KEY%"; // Vercel will replace this with your environment variable
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const systemPrompt = "You are a world-class digital forensics expert specializing in detecting AI-generated images (deepfakes). Your analysis should be critical and detailed.";
            const userQuery = `Analyze this image for signs of AI generation or deepfake manipulation. Provide a main probability score (0-100). If you are extremely confident the image is authentic with no signs of manipulation, the score should be between 0 and 2. Provide a short one-sentence verdict, and a concise overall analysis. Provide a detailed forensic breakdown as an array of objects for these exact categories: 'Lighting & Shadows', 'Skin Texture', 'Eye & Face Consistency', and 'Background Anomalies'. Each object in the array must have 'category', 'score' (0-100), and 'reason' keys. Finally, identify potential manipulation hotspots as an array of objects called 'heatmap_regions'. Each object should have 'x', 'y', 'width', 'height' as percentages of the image dimensions, and a 'confidence' score (0-1).`;

            const payload = {
                systemInstruction: { parts: [{ text: systemPrompt }] },
                contents: [ { role: "user", parts: [ { text: userQuery }, { inlineData: { mimeType: fileObject.type, data: base64ImageData } } ] } ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            probability: { type: "NUMBER" }, verdict: { type: "STRING" }, analysis: { type: "STRING" },
                            forensics: { type: "ARRAY", items: { type: "OBJECT", properties: { category: { type: "STRING" }, score: { type: "NUMBER" }, reason: { type: "STRING" } }, required: ["category", "score", "reason"] } },
                            heatmap_regions: { type: "ARRAY", items: { type: "OBJECT", properties: { x: { type: "NUMBER" }, y: { type: "NUMBER" }, width: { type: "NUMBER" }, height: { type: "NUMBER" }, confidence: { type: "NUMBER" } }, required: ["x", "y", "width", "height", "confidence"] } }
                        },
                        required: ["probability", "verdict", "analysis", "forensics", "heatmap_regions"]
                    }
                }
            };

            try {
                let response; let retries = 3; let delay = 1000;
                for (let i = 0; i < retries; i++) {
                    response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (response.ok) break;
                    if (response.status === 429 || response.status >= 500) { await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; } 
                    else { break; }
                }
                
                if (!response.ok) { const errorBody = await response.json(); throw new Error(`API Error: ${response.status} - ${errorBody.error?.message || 'Unknown error'}`); }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const parsedJson = JSON.parse(candidate.content.parts[0].text);
                    displayResults(parsedJson);
                } else {
                    throw new Error("Invalid response structure from the API.");
                }

            } catch (error) {
                console.error("Analysis failed:", error);
                showError(error.message);
            } finally {
                loadingState.classList.add('hidden');
                analyzeBtn.disabled = false;
            }
        }
        
        function drawHeatmap(regions) {
            const ctx = heatmapCanvas.getContext('2d');
            const img = imagePreview;

            heatmapCanvas.width = img.clientWidth;
            heatmapCanvas.height = img.clientHeight;
            ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
            heatmapCanvas.style.display = 'none';
            if (!regions || regions.length === 0) { return; }
            heatmapCanvas.style.display = 'block';

            regions.forEach(region => {
                const x = (region.x / 100) * heatmapCanvas.width;
                const y = (region.y / 100) * heatmapCanvas.height;
                const width = (region.width / 100) * heatmapCanvas.width;
                const height = (region.height / 100) * heatmapCanvas.height;
                const confidence = region.confidence;
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const radius = Math.max(width, height) * 0.75;
                if (radius <= 0) return;

                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, `rgba(255, 0, 0, ${confidence * 0.7})`);
                gradient.addColorStop(0.5, `rgba(255, 100, 0, ${confidence * 0.3})`);
                gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, width, height);
            });
        }

        function displayResults(data) {
            loadingState.classList.add('hidden');
            resultsContent.classList.remove('hidden');
            errorState.classList.add('hidden');

            const probability = Math.round(data.probability);
            const verdict = data.verdict;
            const analysis = data.analysis;

            probabilityText.textContent = `${probability}%`;
            verdictText.textContent = verdict;
            analysisText.textContent = analysis;

            const circumference = 2 * Math.PI * 58;
            const offset = circumference - (probability / 100) * circumference;
            progressCircle.style.strokeDashoffset = offset;

            if (probability >= 75) {
                progressCircle.classList.remove('text-indigo-500', 'text-yellow-500'); progressCircle.classList.add('text-red-500');
                verdictText.classList.remove('text-indigo-400', 'text-yellow-400'); verdictText.classList.add('text-red-400');
            } else if (probability >= 40) {
                progressCircle.classList.remove('text-indigo-500', 'text-red-500'); progressCircle.classList.add('text-yellow-500');
                verdictText.classList.remove('text-indigo-400', 'text-red-400'); verdictText.classList.add('text-yellow-400');
            } else {
                progressCircle.classList.remove('text-yellow-500', 'text-red-500'); progressCircle.classList.add('text-indigo-500');
                verdictText.classList.remove('text-yellow-400', 'text-red-400'); verdictText.classList.add('text-indigo-400');
            }

            drawHeatmap(data.heatmap_regions);

            if (data.forensics && data.forensics.length > 0) {
                forensicsList.innerHTML = ''; 
                data.forensics.forEach(item => {
                    const score = Math.round(item.score);
                    let colorClass = 'bg-indigo-500'; let textColorClass = 'text-indigo-300';
                    if (score >= 75) { colorClass = 'bg-red-500'; textColorClass = 'text-red-300'; } 
                    else if (score >= 40) { colorClass = 'bg-yellow-500'; textColorClass = 'text-yellow-300'; }

                    const reportItem = `<div class="bg-gray-800 p-3 rounded-lg"><div class="flex justify-between items-center mb-1"><p class="font-semibold text-sm">${item.category}</p><p class="font-bold text-sm ${textColorClass}">${score}%</p></div><div class="w-full bg-gray-700 rounded-full h-2"><div class="${colorClass} h-2 rounded-full" style="width: ${score}%"></div></div><p class="text-xs text-gray-400 mt-2">${item.reason}</p></div>`;
                    forensicsList.innerHTML += reportItem;
                });
                forensicsReport.classList.remove('hidden');
            } else {
                 forensicsReport.classList.add('hidden');
            }
        }
        
        function showError(message) {
            loadingState.classList.add('hidden');
            resultsContainer.classList.remove('hidden'); // Show the results area to display the error
            resultsContent.classList.add('hidden');
            errorState.classList.remove('hidden');
            errorMessage.textContent = message;
        }

    </script>

</body>
</html>



